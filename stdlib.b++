//(((/**
* libreria std de Banana++
*/)))

// requerir variables que tienen que estar, y que no se declaran por codigo
require Sys.PathSep Sys.PathDelimiter;
//(((representa nada en absoluto)))
out null = "";
//(((valor boolean para representar que no es cierta una condicion)))
out False = "false";
//(((valor boolean para representar que es cierta una condicion)))
out True = "true";
//(((funcion para instanciar un valor booleano)))
out function Boolean.new(this:key, Val:boolean)
{
    //(((representa el valor interno de %{this}%)))
    out %{this}% = %{Val}%; 
    //(((esta funcion invierte el valor interno de %{this}%)))
    out function %{this}%.not()
    {
        if Syntax["%{this}%==true"] then { out %{this}% = "false"; }
        else { out %{this}% = "true"; }
    }
    //((esta funcion ))
    out function %{this}%.and(other:boolean)
    {
        TrueTwo = "true";
        // comparar los dos si son verdadero
        if Syntax["%{this}%==false"] then { TrueTwo = False; } if Syntax["%{other}%==false"] then { TrueTwo = False; }
        // devolver el resultado
        out %{this}% = TrueTwo;
    }
    if Syntax["%{Val}%==true"] then { }
    else { if Syntax["%{Val}%==false"] then { } else { Sys.Warn "El valor es invalido" } }
}
//(((instancia el tipo de array, un array es una lista de elementos
que puede ser indexados, cambiados y contables)))
out function Array.new(this:key, Ty:lang_type)
{
    //(((la cantidad de elementos de %{this}%)))
    out #%{this}% = 0;
    //(((añade un elemento hasta la ultima posicion de la lista %{this}%)))
    out function %{this}%.push(item:%{Ty}%)
    {
        // añade el elemento a la lista
        out %{this}%[@get[#%{this}%]] = %{item}%;
        // incrementa la longitud
        out #%{this}% += 1;
    }
    //(((elimina el ultimo elemento de la lista %{this}%)))
    out function %{this}%.pop()
    {
        // decrementa la longitud
        out #%{this}% -= 1;
        // setea a null
        out %{this}%[@get[#%{this}%]] = null;
    }
}
//(((obtiene un elemento de un array desde fuera)))
out function Array.GetFrom(array:Array, index:num, reton:out)
{
    Sys.Out Syntax[VarSyntax[%{array}%[@get[%{index}%]]]]
    // devolverlo
    out %{reton}% = Syntax[VarSyntax[%{array}%[@get[%{index}%]]]];
}
//(((contiene las funciones del sistema)))
out function SysInternal.new(this:key)
{
    //(((imprime algo en pantalla)))
    out function %{this}%.print(Str:str) {
         Sys.Out %{Str}% //
    }
    //(((lee algo que pondra el usuario)))
    out function %{this}%.readline(Ask:str, Out:Out[str]) { 
        out %{Out}% = Sys.Read[%{Ask}%]; 
    }
}
//(((el tipo de strings, un string es una secuencia de caracteres como letras y numeros juntos para formar texto)))
out function String.new(this:key, Str:str)
{
    //(((contiene el contenido interno de %{this}%)))
    out %{this}% = %{Str}%;
    //(((une %{this}% con otro string ya sea instanciado con esta clase o uno plano)))
    out function %{this}%.join(OtherStr:str)
    {
        out %{this}% $= %{OtherStr}%;
    }
    //(((extrae una secuencia de texto empezando desde un inicio (que empieza en 0
     para el primer caracter) y la longitud de la cadena que se extraera, el ultimo
      parametro es la variable donde retornara el string, esta se instanciara automaticamente 
      con esta clase)))
    out function %{this}%.substring(Start:num, Lenstr:num, Out:Out[str])
    {
        // empezar el index
        out index = %{Start}%;

        // vaciar la cadena
        String.new(%{Out}%, "");

        for (%{Lenstr}%)
        {
            // obtiene el caracter actual
            Sys.__str__ = %{this}%; Sys.__char__ = index; Sys.GetChar char
            // lo une
            %{Out}%.join(char);
            // siguiente caracter
            out index += 1;
        }
    }
    //(((verifica si el string %{this}% inicia con una sentencia, que es el primer parametro
    el segundo es el boolean que retornara true si coincide el inicio y false si no)))
    out function %{this}%.startswith(Str:str,Out:Boolean)
    {
        // obtiene si inicia asi
        len = Sys.Len[%{Str}%]; %{this}%.substring(0, len, stm); out %{Out}% = Syntax["stm==%{Str}%"];
    }
    //(((separa %{this}% en un array mediante un separador que es otro string que contiene
    el separador, solo se permite caracteres por que se ha probado con otros pero se bugea bien feo,
    el segundo parametro contiene el nombre del array que retornara)))
    out function %{this}%.split(Splitter:str, ReturnOn:Array)
    {
        out %{this}% $= %{Splitter}%;
        // la parte actual del string que se usara
        part = "";
        // crear array
        Array.new(%{ReturnOn}%, str);
        // longitud
        len = Sys.len[%{this}%];
        // el indexeador
        index = 0;
        // la longitud del separador
        split_len = Sys.len[%{Splitter}%];

        // indexear
        for (len)
        {
            // obtiene el string
            Sys.__str__ = %{this}%; Sys.__char__ = index; Sys.GetChar ch

            if Syntax["ch==%{Splitter}%"] then { %{ReturnOn}%.push(part);part = "";} 
            else { part $= ch; index += 1;}
        }
        // poner la parte del array
        %{ReturnOn}%.push(part);
        // vaciar la parte actual
        part = "";
    }
}
//(((ShellInternal es la clase internal de la shell y los argumentos, para obtenerlos
y mas funciones del entorno de la shell)))
out function ShellInternal.new(this:key)
{
    //(((obtiene un argumento con un numero que representa el argumento, el segundo
    parametro contiene donde retornara el argumento)))
    out function %{this}%.GetArg(argnum:num, Out:Out[str])
    {
        Array.GetFrom(Sys.Argv, argnum, Out);
    }
}
//(((Colors es una estructura que contiene strings que tienen los codigos de escape de
sus colores correspondientes en la termina, stdout o cualquier fuente de texto o salida
que el interprete tenga permitido manipular)))
out function Colors.new(this:key)
{
    // rojo
    out %{this}%.red = "@ASCII:31m";
    // verde
    out %{this}%.green = "@ASCII:32m";
    // amarillo
    out %{this}%.yellow = "@ASCII:33m";
    // azul
    out %{this}%.blue = "@ASCII:34m";
    // magenta
    out %{this}%.magenta = "@ASCII:35m";
    // cian
    out %{this}%.cyan = "@ASCII:36m";
    // gris
    out %{this}%.gray = "@ASCII:37m";
}
//(((el sistema actual instanciado para poder acceder a sus funciones)))
SysInternal.new(Sys);
//(((la shell actual instanciada)))
ShellInternal.new(Sys.Shell);
//(((instancia de los colores de consola)))
Colors.new(Sys.ConsoleColors);